Ready to code?                                                                                                                   

 Here is Claude's plan:                                                                                                                                                                                                                                                                                                       
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌
 You Are Next - Implementation Plan                                                                                                                                                                                                                                                                                           
                                                        
 Context

 Build an over-the-shoulder 3D multiplayer horror game where 2-4 players run through a dark forest while being chased by a monster. The monster catches players and forces them into annoying text arguments -- win and you're freed, lose and you're eaten. Built with BabylonJS (3D), PartyKit (multiplayer), Vite + React
 (UI), deployed on Vercel. Invite-only for friends.

 Developer iterates solo first (Phases 1-3) before enabling multiplayer (Phase 4+). Monster chat starts as a keyword-matching stub, gets Azure Foundry LLM later.

 ---
 Project Structure

 you-are-next/
 ├── src/
 │   ├── main.tsx                  # React entry point
 │   ├── App.tsx                   # Router: landing, lobby, play
 │   ├── components/
 │   │   ├── BabylonCanvas.tsx     # Canvas + Game lifecycle (useEffect/useRef)
 │   │   ├── MonsterChat.tsx       # Argument overlay
 │   │   ├── HUD.tsx               # Distance to goal, game state
 │   │   └── GameOverScreen.tsx
 │   ├── hooks/
 │   │   └── useGameRoom.ts        # PartySocket connection (Phase 4)
 │   └── styles.css                # Plain CSS for overlays
 │
 ├── game/                          # Shared logic (client + server, pure TS)
 │   ├── types.ts                   # GameState, GameAction, Player, Monster
 │   ├── logic.ts                   # gameUpdater() reducer
 │   ├── constants.ts               # MAP_WIDTH, SPEEDS, etc.
 │   └── chat.ts                    # Monster chat stub + pluggable interface
 │
 ├── party/                         # PartyKit server
 │   ├── index.ts                   # Party.Server implementation
 │   └── monsterLLM.ts             # Azure OpenAI client (Phase 5)
 │
 ├── engine/                        # BabylonJS code (pure TS, no React)
 │   ├── Game.ts                    # State machine, render loop, event callbacks
 │   ├── PlayerController.ts        # Camera hierarchy, input, movement, collisions
 │   ├── RemotePlayer.ts            # Networked player puppet (Phase 4)
 │   ├── Monster.ts                 # Monster mesh + chase AI
 │   ├── AIPlayer.ts                # Bot behavior (Phase 5)
 │   ├── ForestMap.ts               # Ground, trees, rocks, boundaries
 │   ├── Lighting.ts                # Lights, fog, shadows, post-processing
 │   └── MeshFactory.ts             # Primitive mesh + material helpers
 │
 ├── public/
 │   ├── textures/                  # 64x64 low-res textures (Phase 3)
 │   └── sounds/                    # Audio files (Phase 3)
 │
 ├── index.html                     # Vite entry
 ├── vite.config.ts
 ├── partykit.json
 ├── tsconfig.json
 ├── package.json
 ├── .env.example
 └── .gitignore

 ---
 Environment Variables

 # PartyKit
 VITE_PARTYKIT_HOST=127.0.0.1:1999
 # Production: VITE_PARTYKIT_HOST=you-are-next.USERNAME.partykit.dev

 # Invite System (set on PartyKit server via `npx partykit env add`)
 # INVITE_SECRET=change-me-to-a-random-string

 # Azure Foundry LLM (Phase 5 -- set on PartyKit server, leave blank until ready)
 # AZURE_OPENAI_ENDPOINT=https://YOUR_RESOURCE.openai.azure.com
 # AZURE_OPENAI_API_KEY=
 # AZURE_OPENAI_DEPLOYMENT_NAME=
 # AZURE_OPENAI_API_VERSION=2024-12-01-preview

 # Debug
 VITE_DEBUG=false

 Only VITE_PARTYKIT_HOST and VITE_DEBUG are client-side. Everything else lives on the PartyKit server (set via npx partykit env add KEY value).

 ---
 Dependencies

 {
   "dependencies": {
     "react": "^19.0",
     "react-dom": "^19.0",
     "react-router-dom": "^7.0",
     "@babylonjs/core": "^7.0",
     "@babylonjs/loaders": "^7.0",
     "@babylonjs/materials": "^7.0",
     "partysocket": "^1.0",
     "nanoid": "^5.0"
   },
   "devDependencies": {
     "partykit": "^0.0.108",
     "vite": "^6.0",
     "@vitejs/plugin-react": "^4.0",
     "typescript": "^5.5",
     "@types/react": "^19",
     "@types/react-dom": "^19"
   }
 }

 No Tailwind (game UI is minimal, plain CSS is fine), no ESLint config packages (can add later if wanted).

 ---
 Phase 1: Project Scaffolding & Core 3D Engine (Single-Player)

 Goal: Player runs through a 3D forest with over-the-shoulder camera. No monster, no multiplayer.

 Work

 1. Scaffold Vite + React + TypeScript project (index.html, vite.config.ts, tsconfig.json)
 2. Create src/App.tsx with react-router: / (landing) and /play (game)
 3. Create src/components/BabylonCanvas.tsx:
   - useRef for canvas element, useEffect to create/dispose Game instance
   - No SSR workarounds needed (Vite is client-only)
 4. Build engine/Game.ts state machine (LOADING -> PLAYING -> PAUSED -> GAME_OVER)
   - Creates Engine, Scene, runs render loop
   - Exposes event callbacks for React integration (onPlayerCaught, onGameOver, etc.)
 5. Build engine/PlayerController.ts:
   - 3-level camera hierarchy: camRoot (Y rotation) -> yTilt (pitch) -> UniversalCamera (12 units behind)
   - WASD input via ActionManager, movement relative to camera direction
   - mesh.moveWithCollisions() for collision, raycast for ground detection
 6. Build engine/ForestMap.ts:
   - Rectangular ground (100 wide x 300 deep)
   - ~150 primitive trees (cylinder trunk + sphere canopy), densely packed with narrow winding paths
   - Invisible boundary walls on 4 edges
   - Start zone at z=-140, finish zone at z=+140
 7. Build engine/Lighting.ts: hemispheric light + exponential fog (density 0.02, near-black)
 8. Build engine/MeshFactory.ts: createTree(), createRock(), createWall() + dark PBR materials
 9. Create game/constants.ts and game/types.ts with initial values
 10. Create stub party/index.ts, partykit.json, .env.example, .gitignore

 Testable

 - npm run dev -> localhost:5173 -> click Play
 - Dark foggy forest with primitive trees
 - WASD moves player, camera follows behind
 - Run from one end to the other, boundary walls work
 - Console logs when player crosses finish zone

 ---
 Phase 2: Game Mechanics (Monster, Catching, Chat Stub)

 Goal: Monster chases player. Getting caught triggers a text argument. Full single-player game loop.

 Work

 1. Build engine/Monster.ts:
   - Mesh: tall dark cylinder + glowing red sphere eyes (primitives)
   - AI states: PATROL -> CHASE (player within 40 units)
   - Moves toward player at slightly less than player speed
 2. Build game/chat.ts: stub with pre-written monster taunts + keyword-based scoring
   - 3 rounds, keyword match for points, threshold determines win/lose
 3. Build game/logic.ts: gameUpdater() reducer (PLAYER_CAUGHT, CHAT_MESSAGE, ARGUMENT_WON/LOST)
 4. Build src/components/MonsterChat.tsx: fullscreen dark overlay, chat log, text input, timer
 5. Build src/components/HUD.tsx: game phase + distance to goal
 6. Build src/components/GameOverScreen.tsx: win/lose result
 7. Update engine/Game.ts: add ARGUMENT and GAME_OVER states, freeze/resume logic
 8. Wire React <-> BabylonJS: Game fires callbacks, React renders overlays, React calls game.resumeChase() / game.playerEaten()

 Testable

 - Monster patrols, then chases when close
 - Getting caught opens chat overlay, game freezes
 - Type responses, monster has pre-written taunts
 - Win -> freed, chase resumes (can be caught again)
 - Lose -> eaten, camera observes monster
 - Reach far end -> win screen
 - Full loop works end-to-end

 ---
 Phase 3: Polish & Atmosphere (Quake Aesthetic)

 Goal: Make it look and feel like a dark retro horror game.

 Work

 1. Update MeshFactory.ts: low-res textures (64x64) with nearest-neighbor filtering, high roughness, dark albedo
 2. Update ForestMap.ts: better tree placement, fallen logs, rocks, more organic layout
 3. Update Lighting.ts: deeper fog, flickering point lights, shadow generator, film grain + vignette post-processing
 4. Update PlayerController.ts: head bob while running, camera shake on catch
 5. Update Monster.ts: multi-primitive composite mesh, improved chase behavior
 6. Add audio: ambient forest loop, heartbeat on monster proximity, footsteps, catch sting (BabylonJS Sound class)
 7. Update MonsterChat.tsx: horror styling, typewriter text effect
 8. Add textures to public/textures/, sounds to public/sounds/

 Testable

 - Fog limits visibility to ~30 units
 - Monster audible before visible (spatial heartbeat)
 - Film grain + vignette give retro horror feel
 - Chat overlay has horror theming
 - Iterate on feel: fog density, light placement, audio levels

 ---
 Phase 4: Multiplayer (PartyKit)

 Goal: 2-4 players in the same room, see each other, watch arguments together.

 Work

 1. Expand game/types.ts: full GameState with players: Record<string, PlayerState>, MonsterState, ChatState
 2. Expand game/logic.ts: multiplayer gameUpdater() with all action types
 3. Rewrite party/index.ts: authoritative server
   - Monster AI server-side at 20Hz tick
   - Server-authoritative catch detection
   - Client-authoritative player movement (friends-only)
   - Full state broadcast at 20Hz
 4. Build src/hooks/useGameRoom.ts: PartySocket connection, dispatch, state sync
 5. Build engine/RemotePlayer.ts: interpolated puppet driven by network state
 6. Update src/App.tsx: add /lobby/:roomId route with name entry, player list, start button
 7. Update MonsterChat.tsx: all players see chat, only caught player types
 8. Implement "monster assistant" for eaten players:
   - Camera follows monster
   - Simple UI: directional hints + speed boost button on cooldown
   - Server applies as slight monster steering/speed nudges
 9. Wire BabylonCanvas to useGameRoom

 Testable

 - Two browser tabs, different names, same room
 - Both players visible, see each other move
 - Monster chases nearest player
 - Catch pauses for all, everyone sees chat, only caught player types
 - Eaten players can nudge monster
 - Game ends correctly (all eaten or all escaped)

 ---
 Phase 5: AI Players & Azure LLM

 Goal: Bots fill empty slots. Monster chat powered by Azure Foundry LLM.

 Work

 1. Build engine/AIPlayer.ts + server-side simulation in party/index.ts:
   - Bots move toward goal with lateral wobble
   - Evasion when targeted by monster
   - AI auto-loses arguments (pre-written dumb responses)
 2. Build party/monsterLLM.ts: Azure OpenAI client
   - System prompt: annoying, persistent, darkly humorous monster
   - 3 rounds, LLM scores each response 1-10, average >= 6 = win
   - JSON response: { "message": "...", "score": 7 }
 3. Update game/chat.ts: picks LLM if Azure vars configured, stub otherwise

 Testable

 - Solo game spawns 3 AI bots with natural movement
 - AI bots get caught and lose arguments
 - With Azure vars: dynamic LLM responses
 - Without Azure vars: stub still works

 ---
 Phase 6: Deployment & Invite System

 Goal: Live on Vercel + PartyKit, invite-only.

 Work

 1. Invite validation handled by PartyKit server in onConnect:
   - Player sends invite code with connection request (as query param)
   - Server validates HMAC-based self-validating code, rejects invalid
   - No separate API routes, middleware, or cookies needed
 2. Code generation: a simple script or PartyKit HTTP endpoint protected by admin secret
 3. Update landing page: invite code input before room join
 4. Deploy PartyKit: npx partykit deploy + env vars
 5. Deploy to Vercel: vite build -> static output, connect repo
 6. Generate invite codes and share with friends

 Testable

 - Production URL requires invite code to join a room
 - Invalid codes are rejected at WebSocket connection time
 - Full multiplayer works over the internet
 - AI bots fill empty slots, monster chat works

 ---
 Verification Plan

 After each phase:
 1. npm run dev (and npx partykit dev for Phase 4+)
 2. Play through end-to-end manually
 3. Check browser console for errors
 4. Multiplayer: test with 2+ browser tabs
 5. Deployment: test production URLs with invite codes