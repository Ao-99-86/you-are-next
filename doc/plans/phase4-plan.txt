Phase 4 Execution Plan: Full Multiplayer (Authoritative Server)

Summary
Current repo status matches README: Phase 3 is complete and stable; Phase 4 is unstarted.
Next move is to execute full Phase 4 in one structured pass, with server-authoritative monster/catch/argument from the start.

This plan delivers:
1. 2-4 player rooms
2. Shared monster and argument events
3. Lobby + room UX
4. Remote player rendering/interpolation
5. Eaten-player monster-assistant mechanic
6. Phase 4 static/runtime verification gate

Public Interfaces and Type Changes
Add these shared protocol/types in game/types.ts (or split to game/net.ts + game/types.ts).

New room/game state
- RoomPhase = "lobby" | "playing" | "argument" | "game_over"
- PlayerLifeState = "alive" | "caught" | "eaten" | "escaped"
- NetworkPlayerState:
  - id, name, lifeState, position: Vec3, yaw, pitch, connected, lastUpdateMs
- NetworkMonsterState:
  - position: Vec3, yaw, state: MonsterState, targetPlayerId: string | null
- NetworkArgumentState:
  - active: boolean, caughtPlayerId, session: ArgumentSession | null, activeTyperId

Client -> Server messages
- JOIN_ROOM { roomId, name }
- SET_READY { ready: boolean }
- PLAYER_INPUT { seq, moveH, moveV, yaw, pitch, dtMs }
- CHAT_SUBMIT { sessionId, message }
- ASSIST_TARGET { targetPlayerId } (eaten-player assist mechanic)
- REQUEST_START {}

Server -> Client messages
- WELCOME { selfId, roomId, tickRate, maxPlayers }
- ROOM_SNAPSHOT { serverTimeMs, phase, players, monster, argument, result }
- ROOM_EVENT { type, payload }
  - PLAYER_CAUGHT
  - ARGUMENT_STARTED
  - ARGUMENT_ROUND_RESOLVED
  - PLAYER_EATEN
  - PLAYER_ESCAPED
  - GAME_OVER
- ERROR { code, message }

Implementation Plan (Decision Complete)

1. Shared model + reducer expansion
- Extend reducer/state for multiplayer room phase and per-player life states.
- Keep existing argument scoring logic; move invocation authority to server.
- Add deterministic helper for player targeting priority and assistant bias.

2. Authoritative PartyKit server (party/index.ts)
- Replace stub with authoritative room loop at 20 Hz.
- Maintain room state in memory:
  - players map
  - ready states
  - monster state
  - active argument state
  - end-condition state
- Server sim rules:
  - Monster patrol/chase and catch checks run only on server.
  - Only caughtPlayerId can submit CHAT_SUBMIT.
  - Argument win/loss updates server truth; outcomes broadcast to all clients.
  - Eaten-player assist: ASSIST_TARGET gives temporary target weight boost (5s cooldown, 2s effect).
- Broadcast full snapshot every tick; emit events on discrete transitions.

3. Client networking hook (src/hooks/useGameRoom.ts)
- Add PartySocket room connection with reconnect handling.
- Track local selfId, latest snapshot, connection status, ping.
- Send input at 20 Hz while connected and in playing.
- Expose API:
  - connect(roomId, name)
  - setReady, requestStart, sendInput, submitChat, assistTarget

4. Routing + lobby UX
- Add routes:
  - / landing
  - /lobby/:roomId (join/create, player list, ready/start)
  - /play/:roomId (multiplayer game scene)
- Lobby rules:
  - room capacity hard cap 4
  - minimum 2 to start
  - host = first connected player
  - start button enabled only for host when all connected players are ready

5. Babylon multiplayer integration
- Game becomes network-driven for Phase 4:
  - local player transform updated from authoritative snapshots
  - remote players rendered as puppet meshes
  - remote interpolation buffer (100ms) with lerp for position/yaw
- Keep current monster visuals; drive monster transform from server snapshot.
- Argument overlay visibility:
  - shown to all players
  - text input enabled only for activeTyperId
- HUD updates sourced from network room state, not local monster simulation.

6. Eaten-player assistant mechanic
- If player loses argument:
  - life state -> eaten
  - camera enters spectator follow mode
  - client can click alive player in HUD list to send ASSIST_TARGET
- Assist only influences monster target selection; eaten players cannot move or chat-submit.

7. Verification and gating
- Add scripts:
  - verify:phase4:static = typecheck + build
  - verify:phase4:runtime-smoke
- Runtime smoke must validate:
  - two clients join same room and see each other
  - host start works only when ready conditions met
  - shared monster/catch transition sync
  - only caught player can submit argument
  - eaten-player assist changes target behavior signal
  - game-over sync across both clients
  - no console/page errors
- Add doc/verification/phase4-checklist.md and update README phase matrix/TODO queue when done.

Test Cases and Scenarios
1. Room lifecycle
- Create room, second player joins, ready states sync, host starts game.
2. Movement replication
- Player A moves; Player B sees smooth remote movement with interpolation.
3. Authoritative catch/argument
- Server triggers catch; both clients enter argument view; only caught player can type.
4. Argument outcomes
- Win returns caught player to alive/playing; loss marks eaten and enables assist.
5. Assistant mechanic
- Eaten player sends assist target; monster target preference updates and is observable.
6. End conditions
- Escape/wipe conditions propagate identically to all clients.
7. Resilience
- Client reconnect restores latest snapshot without room corruption.

Assumptions and Defaults
- Phase 4 includes full scope now (not split into partial MVP).
- Monster/catch/argument authority is server-side from first Phase 4 commit.
- Tick rate fixed at 20 Hz.
- Room size fixed at 2-4 players.
- No invite-code enforcement in Phase 4 (stays Phase 6).
- No Azure LLM integration in Phase 4 (stays Phase 5).
- Existing single-player runtime scripts remain; new Phase 4 gate is additive.
